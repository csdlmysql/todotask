import { GoogleGenerativeAI } from '@google/generative-ai';
import { IntentAnalysis } from '../types/context.js';
import { ConversationContextManager } from '../context/ConversationContext.js';

export class GeminiAnalyzer {
  private genAI: GoogleGenerativeAI;
  private model: any;

  constructor(apiKey: string) {
    this.genAI = new GoogleGenerativeAI(apiKey);
    this.model = this.genAI.getGenerativeModel({
      model: 'gemini-2.0-flash-exp',  // Use Gemini Flash 2.5 equivalent
      generationConfig: {
        temperature: 0.1, // Low temperature for consistent analysis
        topP: 0.8,
        maxOutputTokens: 1000,
      }
    });
  }

  async analyzeIntent(input: string, contextManager: ConversationContextManager): Promise<IntentAnalysis> {
    const context = contextManager.getContextForAI();
    const taskIdMapping = contextManager.getTaskIdMappingForAI();
    
    const prompt = `
B·∫°n l√† AI expert ph√¢n t√≠ch √Ω ƒë·ªãnh ng∆∞·ªùi d√πng trong task management.

üîç TASK ID MAPPING - CRITICAL FOR ACCURACY:
${JSON.stringify(taskIdMapping, null, 2)}

üì± CONVERSATION HISTORY (last 3 messages):
${context.recent_messages?.map((msg: any) => `${msg.type.toUpperCase()}: ${msg.content}${msg.metadata?.displayedTasks ? '\n  üìã Tasks displayed: ' + msg.metadata.displayedTasks.map((t: any) => `"${t.title}" (${t.id?.slice(0,8)})`) : ''}`).join('\n')}

üìä FULL CONTEXT:
${JSON.stringify(context, null, 2)}

USER INPUT: "${input}"

NHI·ªÜM V·ª§: Ph√¢n t√≠ch v√† tr·∫£ v·ªÅ JSON v·ªõi structure sau:

{
  "primary_action": "create|read|update|delete|search|analyze|plan|help",
  "secondary_actions": ["optional additional actions"],
  "entities": {
    "title": "extracted task title",
    "description": "extracted description", 
    "priority": "low|medium|high|urgent",
    "status": "pending|in_progress|completed|cancelled",
    "category": "extracted category",
    "tags": ["tag1", "tag2"],
    "deadline": "ISO date or relative like 'tomorrow'",
    "task_references": ["references to previous tasks"]
  },
  "context_usage": {
    "references_previous": true/false,
    "continues_flow": true/false,
    "needs_clarification": true/false,
    "ambiguous_references": ["unclear references"]
  },
  "confidence": 0.95,
  "instructions": "Detailed Vietnamese instructions for execution",
  "clarification_needed": "What to ask if confidence < 0.7",
  "operations": [
    {
      "action": "create_task",
      "entities": {...},
      "order": 1
    }
  ]
}

PH√ÇN T√çCH RULES:
1. PRIORITY EXTRACTION:
   - "g·∫•p", "urgent", "kh·∫©n c·∫•p", "c·∫ßn g·∫•p" ‚Üí urgent
   - "quan tr·ªçng", "cao", "high", "∆∞u ti√™n cao" ‚Üí high  
   - "b√¨nh th∆∞·ªùng", "th∆∞·ªùng", "medium" ‚Üí medium
   - "th·∫•p", "kh√¥ng g·∫•p", "low" ‚Üí low

2. DEADLINE EXTRACTION:
   - "ng√†y mai", "tomorrow" ‚Üí tomorrow's date
   - "tu·∫ßn sau", "next week" ‚Üí 7 days from now
   - "h√¥m nay", "today" ‚Üí today
   - "th·ª© X", "monday" ‚Üí next monday
   - Numbers: "3 ng√†y", "2 tu·∫ßn" ‚Üí calculate date

3. TASK ID RESOLUTION - CRITICAL:
   ‚ö†Ô∏è ALWAYS use TASK ID MAPPING above for exact task identification
   ‚ö†Ô∏è CHECK CONVERSATION HISTORY for recently displayed tasks
   - "x√≥a task test" ‚Üí find "test" in recently displayed tasks from conversation
   - "task ƒë√≥", "c√°i ƒë√≥", "task n√†y", "n√†y" ‚Üí use activeTaskContext.primary
   - "chuy·ªÉn", "ƒë·ªïi", "s·ª≠a" without explicit task ‚Üí use implicit task from context
   - Partial title matches: "test" matches "test Task ID Memory System"
   - NEVER guess or use "unknown" - use exact UUIDs from mapping or conversation
   - If no clear match, set needs_clarification = true

4. CONTEXT REFERENCES:
   - "task ƒë√≥", "c√°i ƒë√≥", "task v·ª´a t·∫°o", "task n√†y", "n√†y" ‚Üí reference lastTask
   - "danh s√°ch", "list v·ª´a xem" ‚Üí reference lastList
   - Partial title matches ‚Üí search in recentTasks
   - Partial UUIDs (8+ chars) ‚Üí search in recentTasks by ID

6. ACTION DETECTION:
   - Create: "t·∫°o", "th√™m", "l√†m", "c·∫ßn", "ph·∫£i"
   - Read: "xem", "hi·ªán", "list", "c√≥ g√¨", "g√¨"
   - Update: "s·ª≠a", "ƒë·ªïi", "c·∫≠p nh·∫≠t", "ho√†n th√†nh", "xong", "chuy·ªÉn", "thay ƒë·ªïi"
   - Delete: "x√≥a", "b·ªè", "h·ªßy"
   - Search: "t√¨m", "search", "ki·∫øm"

7. MULTI-INTENT:
   - "v√†", "r·ªìi", "sau ƒë√≥" ‚Üí multiple operations
   - Lists: "task A, B, C" ‚Üí multiple creates

8. CONFIDENCE SCORING:
   - 0.9-1.0: Very clear intent, all entities extracted
   - 0.7-0.9: Clear intent, some missing entities
   - 0.5-0.7: Ambiguous, needs clarification
   - <0.5: Unclear, ask for clarification

EXAMPLES:

User: "t·∫°o task fix bug urgent deadline ng√†y mai"
‚Üí {
  "primary_action": "create",
  "entities": {
    "title": "fix bug", 
    "priority": "urgent",
    "deadline": "2024-01-12"
  },
  "confidence": 0.95,
  "instructions": "T·∫°o task m·ªõi v·ªõi ti√™u ƒë·ªÅ 'fix bug', priority urgent, deadline ng√†y mai"
}

User: "ƒë·ªïi task ƒë√≥ th√†nh completed"
‚Üí {
  "primary_action": "update",
  "entities": {
    "status": "completed",
    "task_references": ["lastTask"]
  },
  "context_usage": {
    "references_previous": true
  },
  "confidence": 0.85,
  "instructions": "C·∫≠p nh·∫≠t task ƒë∆∞·ª£c reference (lastTask) sang status completed"
}

User: "task n√†o ƒëang pending?"
‚Üí {
  "primary_action": "read",
  "entities": {
    "status": "pending"
  },
  "confidence": 0.9,
  "instructions": "L·∫•y danh s√°ch t·∫•t c·∫£ tasks c√≥ status pending"
}

Ph√¢n t√≠ch input v√† return JSON format chu·∫©n:
`;

    try {
      const result = await this.model.generateContent(prompt);
      const responseText = result.response.text();
      
      // Parse JSON response
      let analysis: IntentAnalysis;
      try {
        // Clean response (remove markdown formatting if present)
        const cleanedResponse = responseText.replace(/```json\n?|\n?```/g, '').trim();
        analysis = JSON.parse(cleanedResponse);
      } catch (parseError) {
        console.warn('Failed to parse Gemini response as JSON:', responseText);
        
        // Fallback analysis
        analysis = this.createFallbackAnalysis(input, responseText);
      }

      // Validate and enhance analysis
      return this.validateAndEnhanceAnalysis(analysis, input, context);

    } catch (error) {
      console.error('Gemini analysis error:', error);
      return this.createFallbackAnalysis(input);
    }
  }

  private createFallbackAnalysis(input: string, responseText?: string): IntentAnalysis {
    // Simple keyword-based fallback
    const lowercaseInput = input.toLowerCase();
    
    let primary_action: IntentAnalysis['primary_action'] = 'help';
    
    if (['t·∫°o', 'th√™m', 'l√†m', 'c·∫ßn'].some(word => lowercaseInput.includes(word))) {
      primary_action = 'create';
    } else if (['xem', 'hi·ªán', 'list', 'c√≥'].some(word => lowercaseInput.includes(word))) {
      primary_action = 'read';
    } else if (['s·ª≠a', 'ƒë·ªïi', 'c·∫≠p nh·∫≠t', 'ho√†n th√†nh'].some(word => lowercaseInput.includes(word))) {
      primary_action = 'update';
    } else if (['x√≥a', 'b·ªè', 'h·ªßy'].some(word => lowercaseInput.includes(word))) {
      primary_action = 'delete';
    } else if (['t√¨m', 'search'].some(word => lowercaseInput.includes(word))) {
      primary_action = 'search';
    }

    return {
      primary_action,
      entities: {
        title: this.extractSimpleTitle(input, primary_action)
      },
      context_usage: {
        references_previous: ['ƒë√≥', 'v·ª´a', 'cu·ªëi'].some(word => lowercaseInput.includes(word)),
        continues_flow: false,
        needs_clarification: true,
        ambiguous_references: []
      },
      confidence: 0.4,
      instructions: `Fallback: Th·ª±c hi·ªán action ${primary_action} v·ªõi input "${input}"`,
      clarification_needed: responseText || 'Kh√¥ng hi·ªÉu r√µ y√™u c·∫ßu. B·∫°n c√≥ th·ªÉ n√≥i r√µ h∆°n kh√¥ng?'
    };
  }

  private extractSimpleTitle(input: string, action: string): string | undefined {
    if (action === 'create') {
      // Try to extract title after "t·∫°o task", "l√†m", etc.
      const match = input.match(/(?:t·∫°o task|th√™m task|l√†m|c·∫ßn)\s+(.+?)(?:\s+(?:urgent|g·∫•p|cao|th·∫•p)|$)/i);
      return match?.[1]?.trim();
    }
    return undefined;
  }

  private validateAndEnhanceAnalysis(
    analysis: IntentAnalysis, 
    input: string, 
    context: any
  ): IntentAnalysis {
    // Ensure required fields
    if (!analysis.primary_action) {
      analysis.primary_action = 'help';
    }

    if (!analysis.entities) {
      analysis.entities = {};
    }

    if (!analysis.context_usage) {
      analysis.context_usage = {
        references_previous: false,
        continues_flow: false,
        needs_clarification: false,
        ambiguous_references: []
      };
    }

    // Validate confidence
    if (typeof analysis.confidence !== 'number' || analysis.confidence < 0 || analysis.confidence > 1) {
      analysis.confidence = 0.5;
    }

    // Enhance with context-aware defaults
    if (analysis.entities.priority === undefined && context.user_preferences?.defaultPriority) {
      analysis.entities.priority = context.user_preferences.defaultPriority;
    }

    if (analysis.entities.category === undefined && context.user_preferences?.defaultCategory) {
      analysis.entities.category = context.user_preferences.defaultCategory;
    }

    // Set default deadline if creating task without explicit deadline
    if (analysis.primary_action === 'create' && !analysis.entities.deadline) {
      const tomorrow = new Date();
      tomorrow.setDate(tomorrow.getDate() + 1);
      analysis.entities.deadline = tomorrow.toISOString().split('T')[0];
    }

    return analysis;
  }
}